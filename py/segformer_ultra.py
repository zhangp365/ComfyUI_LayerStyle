'''
ÂéüÂßã‰ª£Á†ÅÊù•Ëá™ https://github.com/StartHua/Comfyui_segformer_b2_clothes
'''

from transformers import SegformerImageProcessor, AutoModelForSemanticSegmentation
import torch.nn as nn
from .imagefunc import *


class SegformerPipeline:
    def __init__(self):
        self.model_name = ''
        self.segment_label = []

SegPipeline = SegformerPipeline()

# ÂàáÂâ≤ÊúçË£Ö
def get_segmentation(tensor_image, model_name='segformer_b2_clothes'):
    cloth = tensor2pil(tensor_image)
    model_folder_path = os.path.join(folder_paths.models_dir, model_name)
    try:
        model_folder_path = os.path.normpath(folder_paths.folder_names_and_paths[model_name][0][0])
    except:
        pass

    processor = SegformerImageProcessor.from_pretrained(model_folder_path)
    model = AutoModelForSemanticSegmentation.from_pretrained(model_folder_path)
    # È¢ÑÂ§ÑÁêÜÂíåÈ¢ÑÊµã
    inputs = processor(images=cloth, return_tensors="pt")
    outputs = model(**inputs)
    logits = outputs.logits.cpu()
    upsampled_logits = nn.functional.interpolate(logits, size=cloth.size[::-1], mode="bilinear", align_corners=False)
    pred_seg = upsampled_logits.argmax(dim=1)[0].numpy()
    return pred_seg,cloth


class Segformer_B2_Clothes:

    def __init__(self):
        self.NODE_NAME = 'SegformerB2ClothesUltra'


    # Labels: 0: "Background", 1: "Hat", 2: "Hair", 3: "Sunglasses", 4: "Upper-clothes", 5: "Skirt",
    # 6: "Pants", 7: "Dress", 8: "Belt", 9: "Left-shoe", 10: "Right-shoe", 11: "Face",
    # 12: "Left-leg", 13: "Right-leg", 14: "Left-arm", 15: "Right-arm", 16: "Bag", 17: "Scarf"

    @classmethod
    def INPUT_TYPES(cls):
        method_list = ['VITMatte', 'VITMatte(local)', 'PyMatting', 'GuidedFilter', ]
        device_list = ['cuda', 'cpu']
        return {"required":
            {
                "image": ("IMAGE",),
                "face": ("BOOLEAN", {"default": False}),
                "hair": ("BOOLEAN", {"default": False}),
                "hat": ("BOOLEAN", {"default": False}),
                "sunglass": ("BOOLEAN", {"default": False}),
                "left_arm": ("BOOLEAN", {"default": False}),
                "right_arm": ("BOOLEAN", {"default": False}),
                "left_leg": ("BOOLEAN", {"default": False}),
                "right_leg": ("BOOLEAN", {"default": False}),
                "upper_clothes": ("BOOLEAN", {"default": False}),
                "skirt": ("BOOLEAN", {"default": False}),
                "pants": ("BOOLEAN", {"default": False}),
                "dress": ("BOOLEAN", {"default": False}),
                "belt": ("BOOLEAN", {"default": False}),
                "shoe": ("BOOLEAN", {"default": False}),
                "bag": ("BOOLEAN", {"default": False}),
                "scarf": ("BOOLEAN", {"default": False}),
                "detail_method": (method_list,),
                "detail_erode": ("INT", {"default": 12, "min": 1, "max": 255, "step": 1}),
                "detail_dilate": ("INT", {"default": 6, "min": 1, "max": 255, "step": 1}),
                "black_point": (
                "FLOAT", {"default": 0.15, "min": 0.01, "max": 0.98, "step": 0.01, "display": "slider"}),
                "white_point": (
                "FLOAT", {"default": 0.99, "min": 0.02, "max": 0.99, "step": 0.01, "display": "slider"}),
                "process_detail": ("BOOLEAN", {"default": True}),
                "device": (device_list,),
                "max_megapixels": ("FLOAT", {"default": 2.0, "min": 1, "max": 999, "step": 0.1}),
            }
        }

    RETURN_TYPES = ("IMAGE", "MASK",)
    RETURN_NAMES = ("image", "mask",)
    FUNCTION = "segformer_ultra"
    CATEGORY = 'üò∫dzNodes/LayerMask'

    def segformer_ultra(self, image,
                        face, hat, hair, sunglass, upper_clothes, skirt, pants, dress, belt, shoe,
                        left_leg, right_leg, left_arm, right_arm, bag, scarf, detail_method,
                        detail_erode, detail_dilate, black_point, white_point, process_detail, device, max_megapixels,
                        ):

        ret_images = []
        ret_masks = []

        if detail_method == 'VITMatte(local)':
            local_files_only = True
        else:
            local_files_only = False

        for i in image:
            pred_seg, cloth = get_segmentation(i)
            i = torch.unsqueeze(i, 0)
            i = pil2tensor(tensor2pil(i).convert('RGB'))
            orig_image = tensor2pil(i).convert('RGB')

            labels_to_keep = [0]
            if not hat:
                labels_to_keep.append(1)
            if not hair:
                labels_to_keep.append(2)
            if not sunglass:
                labels_to_keep.append(3)
            if not upper_clothes:
                labels_to_keep.append(4)
            if not skirt:
                labels_to_keep.append(5)
            if not pants:
                labels_to_keep.append(6)
            if not dress:
                labels_to_keep.append(7)
            if not belt:
                labels_to_keep.append(8)
            if not shoe:
                labels_to_keep.append(9)
                labels_to_keep.append(10)
            if not face:
                labels_to_keep.append(11)
            if not left_leg:
                labels_to_keep.append(12)
            if not right_leg:
                labels_to_keep.append(13)
            if not left_arm:
                labels_to_keep.append(14)
            if not right_arm:
                labels_to_keep.append(15)
            if not bag:
                labels_to_keep.append(16)
            if not scarf:
                labels_to_keep.append(17)

            mask = np.isin(pred_seg, labels_to_keep).astype(np.uint8)

            # ÂàõÂª∫agnostic-maskÂõæÂÉè
            mask_image = Image.fromarray((1 - mask) * 255)
            mask_image = mask_image.convert("L")
            _mask = pil2tensor(mask_image)

            detail_range = detail_erode + detail_dilate
            if process_detail:
                if detail_method == 'GuidedFilter':
                    _mask = guided_filter_alpha(i, _mask, detail_range // 6 + 1)
                    _mask = tensor2pil(histogram_remap(_mask, black_point, white_point))
                elif detail_method == 'PyMatting':
                    _mask = tensor2pil(mask_edge_detail(i, _mask, detail_range // 8 + 1, black_point, white_point))
                else:
                    _trimap = generate_VITMatte_trimap(_mask, detail_erode, detail_dilate)
                    _mask = generate_VITMatte(orig_image, _trimap, local_files_only=local_files_only, device=device,
                                              max_megapixels=max_megapixels)
                    _mask = tensor2pil(histogram_remap(pil2tensor(_mask), black_point, white_point))
            else:
                _mask = mask2image(_mask)

            ret_image = RGB2RGBA(orig_image, _mask.convert('L'))
            ret_images.append(pil2tensor(ret_image))
            ret_masks.append(image2mask(_mask))

        log(f"{self.NODE_NAME} Processed {len(ret_images)} image(s).", message_type='finish')
        return (torch.cat(ret_images, dim=0), torch.cat(ret_masks, dim=0),)

class SegformerClothesPipelineLoader:

    def __init__(self):
        self.NODE_NAME = 'SegformerClothesPipelineLoader'
        pass

    # Labels: 0: "Background", 1: "Hat", 2: "Hair", 3: "Sunglasses", 4: "Upper-clothes",
    # 5: "Skirt", 6: "Pants", 7: "Dress", 8: "Belt", 9: "Left-shoe", 10: "Right-shoe",
    # 11: "Face", 12: "Left-leg", 13: "Right-leg", 14: "Left-arm", 15: "Right-arm",
    #  17: "Scarf"

    @classmethod
    def INPUT_TYPES(cls):
        model_list = ['segformer_b3_clothes', 'segformer_b2_clothes']
        return {"required":
            {   "model": (model_list,),
                "face": ("BOOLEAN", {"default": False, "label_on": "enabled(ËÑ∏)", "label_off": "disabled(ËÑ∏)"}),
                "hair": ("BOOLEAN", {"default": False, "label_on": "enabled(Â§¥Âèë)", "label_off": "disabled(Â§¥Âèë)"}),
                "hat": ("BOOLEAN", {"default": False, "label_on": "enabled(Â∏ΩÂ≠ê)", "label_off": "disabled(Â∏ΩÂ≠ê)"}),
                "sunglass": ("BOOLEAN", {"default": False, "label_on": "enabled(Â¢®Èïú)", "label_off": "disabled(Â¢®Èïú)"}),
                "left_arm": ("BOOLEAN", {"default": False, "label_on": "enabled(Â∑¶ËáÇ)", "label_off": "disabled(Â∑¶ËáÇ)"}),
                "right_arm": ("BOOLEAN", {"default": False, "label_on": "enabled(Âè≥ËáÇ)", "label_off": "disabled(Âè≥ËáÇ)"}),
                "left_leg": ("BOOLEAN", {"default": False, "label_on": "enabled(Â∑¶ËÖø)", "label_off": "disabled(Â∑¶ËÖø)"}),
                "right_leg": ("BOOLEAN", {"default": False, "label_on": "enabled(Âè≥ËÖø)", "label_off": "disabled(Âè≥ËÖø)"}),
                "left_shoe": ("BOOLEAN", {"default": False, "label_on": "enabled(Â∑¶Èûã)", "label_off": "disabled(Â∑¶Èûã)"}),
                "right_shoe": ("BOOLEAN", {"default": False, "label_on": "enabled(Âè≥Èûã)", "label_off": "disabled(Âè≥Èûã)"}),
                "upper_clothes": ("BOOLEAN", {"default": False, "label_on": "enabled(‰∏äË°£)", "label_off": "disabled(‰∏äË°£)"}),
                "skirt": ("BOOLEAN", {"default": False, "label_on": "enabled(Áü≠Ë£ô)", "label_off": "disabled(Áü≠Ë£ô)"}),
                "pants": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë£§Â≠ê)", "label_off": "disabled(Ë£§Â≠ê)"}),
                "dress": ("BOOLEAN", {"default": False, "label_on": "enabled(ËøûË°£Ë£ô)", "label_off": "disabled(ËøûË°£Ë£ô)"}),
                "belt": ("BOOLEAN", {"default": False, "label_on": "enabled(ËÖ∞Â∏¶)", "label_off": "disabled(ËÖ∞Â∏¶)"}),
                "bag": ("BOOLEAN", {"default": False, "label_on": "enabled(ËÉåÂåÖ)", "label_off": "disabled(ËÉåÂåÖ)"}),
                "scarf": ("BOOLEAN", {"default": False, "label_on": "enabled(Âõ¥Â∑æ)", "label_off": "disabled(Âõ¥Â∑æ)"}),
            }
        }

    RETURN_TYPES = ("SegPipeline",)
    RETURN_NAMES = ("segformer_pipeline",)
    FUNCTION = "segformer_clothes_pipeline_loader"
    CATEGORY = 'üò∫dzNodes/LayerMask'

    def segformer_clothes_pipeline_loader(self, model,
                        face, hat, hair, sunglass,
                        left_leg, right_leg, left_arm, right_arm, left_shoe, right_shoe,
                        upper_clothes, skirt, pants, dress, belt, bag, scarf,
                        ):

        pipeline = SegformerPipeline()
        labels_to_keep = [0]
        if not hat:
            labels_to_keep.append(1)
        if not hair:
            labels_to_keep.append(2)
        if not sunglass:
            labels_to_keep.append(3)
        if not upper_clothes:
            labels_to_keep.append(4)
        if not skirt:
            labels_to_keep.append(5)
        if not pants:
            labels_to_keep.append(6)
        if not dress:
            labels_to_keep.append(7)
        if not belt:
            labels_to_keep.append(8)
        if not left_shoe:
            labels_to_keep.append(9)
        if not right_shoe:
            labels_to_keep.append(10)
        if not face:
            labels_to_keep.append(11)
        if not left_leg:
            labels_to_keep.append(12)
        if not right_leg:
            labels_to_keep.append(13)
        if not left_arm:
            labels_to_keep.append(14)
        if not right_arm:
            labels_to_keep.append(15)
        if not bag:
            labels_to_keep.append(16)
        if not scarf:
            labels_to_keep.append(17)
        pipeline.segment_label = labels_to_keep
        pipeline.model_name = model
        return (pipeline,)

class SegformerFashionPipelineLoader:

    def __init__(self):
        self.NODE_NAME = 'SegformerFashionPipelineLoader'
        pass

    @classmethod
    def INPUT_TYPES(cls):
        model_list = ['segformer_b3_fashion']
        return {"required":
            {   "model": (model_list,),
                "shirt": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë°¨Ë°´„ÄÅÁΩ©Ë°´)", "label_off": "disabled(Ë°¨Ë°´„ÄÅÁΩ©Ë°´)"}),
                "top": ("BOOLEAN", {"default": False, "label_on": "enabled(‰∏äË°£„ÄÅtÊÅ§)", "label_off": "disabled(‰∏äË°£„ÄÅtÊÅ§)"}),
                "sweater": ("BOOLEAN", {"default": False, "label_on": "enabled(ÊØõË°£)", "label_off": "disabled(ÊØõË°£)"}),
                "cardigan": ("BOOLEAN", {"default": False, "label_on": "enabled(ÂºÄË•üÊØõË°´)", "label_off": "disabled(ÂºÄË•üÊØõË°´)"}),
                "jacket": ("BOOLEAN", {"default": False, "label_on": "enabled(Â§πÂÖã)", "label_off": "disabled(Â§πÂÖã)"}),
                "vest": ("BOOLEAN", {"default": False, "label_on": "enabled(ËÉåÂøÉ)", "label_off": "disabled(ËÉåÂøÉ)"}),
                "pants": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë£§Â≠ê)", "label_off": "disabled(Ë£§Â≠ê)"}),
                "shorts": ("BOOLEAN", {"default": False, "label_on": "enabled(Áü≠Ë£§)", "label_off": "disabled(Áü≠Ë£§)"}),
                "skirt": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë£ôÂ≠ê)", "label_off": "disabled(Ë£ôÂ≠ê)"}),
                "coat": ("BOOLEAN", {"default": False, "label_on": "enabled(Â§ñÂ•ó)", "label_off": "disabled(Â§ñÂ•ó)"}),
                "dress": ("BOOLEAN", {"default": False, "label_on": "enabled(ËøûË°£Ë£ô)", "label_off": "disabled(ËøûË°£Ë£ô)"}),
                "jumpsuit": ("BOOLEAN", {"default": False, "label_on": "enabled(ËøûË∫´Ë£§)", "label_off": "disabled(ËøûË∫´Ë£§)"}),
                "cape": ("BOOLEAN", {"default": False, "label_on": "enabled(ÊñóÁØ∑)", "label_off": "disabled(ÊñóÁØ∑)"}),
                "glasses": ("BOOLEAN", {"default": False, "label_on": "enabled(ÁúºÈïú)", "label_off": "disabled(ÁúºÈïú)"}),
                "hat": ("BOOLEAN", {"default": False, "label_on": "enabled(Â∏ΩÂ≠ê)", "label_off": "disabled(Â∏ΩÂ≠ê)"}),
                "hairaccessory": ("BOOLEAN", {"default": False, "label_on": "enabled(Â§¥Â∏¶)", "label_off": "disabled(Â§¥Â∏¶)"}),
                "tie": ("BOOLEAN", {"default": False, "label_on": "enabled(È¢ÜÂ∏¶)", "label_off": "disabled(È¢ÜÂ∏¶)"}),
                "glove": ("BOOLEAN", {"default": False, "label_on": "enabled(ÊâãÂ•ó)", "label_off": "disabled(ÊâãÂ•ó)"}),
                "watch": ("BOOLEAN", {"default": False, "label_on": "enabled(ÊâãË°®)", "label_off": "disabled(ÊâãË°®)"}),
                "belt": ("BOOLEAN", {"default": False, "label_on": "enabled(ÁöÆÂ∏¶)", "label_off": "disabled(ÁöÆÂ∏¶)"}),
                "legwarmer": ("BOOLEAN", {"default": False, "label_on": "enabled(ËÖøÂ•ó)", "label_off": "disabled(ËÖøÂ•ó)"}),
                "tights": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë£§Ë¢ú)","label_off": "disabled(Ë£§Ë¢ú)"}),
                "sock": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë¢úÂ≠ê)", "label_off": "disabled(Ë¢úÂ≠ê)"}),
                "shoe": ("BOOLEAN", {"default": False, "label_on": "enabled(ÈûãÂ≠ê)", "label_off": "disabled(ÈûãÂ≠ê)"}),
                "bagwallet": ("BOOLEAN", {"default": False, "label_on": "enabled(ÊâãÂåÖ)", "label_off": "disabled(ÊâãÂåÖ)"}),
                "scarf": ("BOOLEAN", {"default": False, "label_on": "enabled(Âõ¥Â∑æ)", "label_off": "disabled(Âõ¥Â∑æ)"}),
                "umbrella": ("BOOLEAN", {"default": False, "label_on": "enabled(Èõ®‰ºû)", "label_off": "disabled(Èõ®‰ºû)"}),
                "hood": ("BOOLEAN", {"default": False, "label_on": "enabled(ÂÖúÂ∏Ω)", "label_off": "disabled(ÂÖúÂ∏Ω)"}),
                "collar": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë°£È¢Ü)", "label_off": "disabled(Ë°£È¢Ü)"}),
                "lapel": ("BOOLEAN", {"default": False, "label_on": "enabled(ÁøªÈ¢Ü)", "label_off": "disabled(ÁøªÈ¢Ü)"}),
                "epaulette": ("BOOLEAN", {"default": False, "label_on": "enabled(ËÇ©Á´†)", "label_off": "disabled(ËÇ©Á´†)"}),
                "sleeve": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë¢ñÂ≠ê)", "label_off": "disabled(Ë¢ñÂ≠ê)"}),
                "pocket": ("BOOLEAN", {"default": False, "label_on": "enabled(Âè£Ë¢ã)", "label_off": "disabled(Âè£Ë¢ã)"}),
                "neckline": ("BOOLEAN", {"default": False, "label_on": "enabled(È¢ÜÂè£)", "label_off": "disabled(È¢ÜÂè£)"}),
                "buckle": ("BOOLEAN", {"default": False, "label_on": "enabled(Â∏¶Êâ£)", "label_off": "disabled(Â∏¶Êâ£)"}),
                "zipper": ("BOOLEAN", {"default": False, "label_on": "enabled(ÊãâÈìæ)", "label_off": "disabled(ÊãâÈìæ)"}),
                "applique": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë¥¥Ëä±)", "label_off": "disabled(Ë¥¥Ëä±)"}),
                "bead": ("BOOLEAN", {"default": False, "label_on": "enabled(Áè†Â≠ê)", "label_off": "disabled(Áè†Â≠ê)"}),
                "bow": ("BOOLEAN", {"default": False, "label_on": "enabled(Ëù¥Ëù∂Áªì)", "label_off": "disabled(Ëù¥Ëù∂Áªì)"}),
                "flower": ("BOOLEAN", {"default": False, "label_on": "enabled(Ëä±)", "label_off": "disabled(Ëä±)"}),
                "fringe": ("BOOLEAN", {"default": False, "label_on": "enabled(ÂàòÊµ∑)", "label_off": "disabled(ÂàòÊµ∑)"}),
                "ribbon": ("BOOLEAN", {"default": False, "label_on": "enabled(‰∏ùÂ∏¶)", "label_off": "disabled(‰∏ùÂ∏¶)"}),
                "rivet": ("BOOLEAN", {"default": False, "label_on": "enabled(ÈìÜÈíâ)", "label_off": "disabled(ÈìÜÈíâ)"}),
                "ruffle": ("BOOLEAN", {"default": False, "label_on": "enabled(Ë§∂È•∞)", "label_off": "disabled(Ë§∂È•∞)"}),
                "sequin": ("BOOLEAN", {"default": False, "label_on": "enabled(‰∫ÆÁâá)", "label_off": "disabled(‰∫ÆÁâá)"}),
                "tassel": ("BOOLEAN", {"default": False, "label_on": "enabled(ÊµÅËãè)", "label_off": "disabled(ÊµÅËãè)"}),
            }
        }

    RETURN_TYPES = ("SegPipeline",)
    RETURN_NAMES = ("segformer_pipeline",)
    FUNCTION = "segformer_fashion_pipeline_loader"
    CATEGORY = 'üò∫dzNodes/LayerMask'

    def segformer_fashion_pipeline_loader(self, model,
                                          shirt, top, sweater, cardigan, jacket, vest, pants,
                                          shorts, skirt, coat, dress, jumpsuit, cape, glasses,
                                          hat, hairaccessory, tie, glove, watch, belt, legwarmer,
                                          tights, sock, shoe, bagwallet, scarf, umbrella, hood,
                                          collar, lapel, epaulette, sleeve, pocket, neckline,
                                          buckle, zipper, applique, bead, bow, flower, fringe,
                                          ribbon, rivet, ruffle, sequin, tassel
                                        ):

        pipeline = SegformerPipeline()
        labels_to_keep = [0]
        if not shirt:
            labels_to_keep.append(1)
        if not top:
            labels_to_keep.append(2)
        if not sweater:
            labels_to_keep.append(3)
        if not cardigan:
            labels_to_keep.append(4)
        if not jacket:
            labels_to_keep.append(5)
        if not vest:
            labels_to_keep.append(6)
        if not pants:
            labels_to_keep.append(7)
        if not shorts:
            labels_to_keep.append(8)
        if not skirt:
            labels_to_keep.append(9)
        if not coat:
            labels_to_keep.append(10)
        if not dress:
            labels_to_keep.append(11)
        if not jumpsuit:
            labels_to_keep.append(12)
        if not cape:
            labels_to_keep.append(13)
        if not glasses:
            labels_to_keep.append(14)
        if not hat:
            labels_to_keep.append(15)
        if not hairaccessory:
            labels_to_keep.append(16)
        if not tie:
            labels_to_keep.append(17)
        if not glove:
            labels_to_keep.append(18)
        if not watch:
            labels_to_keep.append(19)
        if not belt:
            labels_to_keep.append(20)
        if not legwarmer:
            labels_to_keep.append(21)
        if not tights:
            labels_to_keep.append(22)
        if not sock:
            labels_to_keep.append(23)
        if not shoe:
            labels_to_keep.append(24)
        if not bagwallet:
            labels_to_keep.append(25)
        if not scarf:
            labels_to_keep.append(26)
        if not umbrella:
            labels_to_keep.append(27)
        if not hood:
            labels_to_keep.append(28)
        if not collar:
            labels_to_keep.append(29)
        if not lapel:
            labels_to_keep.append(30)
        if not epaulette:
            labels_to_keep.append(31)
        if not sleeve:
            labels_to_keep.append(32)
        if not pocket:
            labels_to_keep.append(33)
        if not neckline:
            labels_to_keep.append(34)
        if not buckle:
            labels_to_keep.append(35)
        if not zipper:
            labels_to_keep.append(36)
        if not applique:
            labels_to_keep.append(37)
        if not bead:
            labels_to_keep.append(38)
        if not bow:
            labels_to_keep.append(39)
        if not flower:
            labels_to_keep.append(40)
        if not fringe:
            labels_to_keep.append(41)
        if not ribbon:
            labels_to_keep.append(42)
        if not rivet:
            labels_to_keep.append(43)
        if not ruffle:
            labels_to_keep.append(44)
        if not sequin:
            labels_to_keep.append(45)
        if not tassel:
            labels_to_keep.append(46)

        pipeline.segment_label = labels_to_keep
        pipeline.model_name = model
        return (pipeline,)

class SegformerUltraV2:

    def __init__(self):
        self.NODE_NAME = 'SegformerUltraV2'
        pass

    @classmethod
    def INPUT_TYPES(cls):
        method_list = ['VITMatte', 'VITMatte(local)', 'PyMatting', 'GuidedFilter', ]
        device_list = ['cuda', 'cpu']
        return {"required":
            {
                "image": ("IMAGE",),
                "segformer_pipeline": ("SegPipeline",),
                "detail_method": (method_list,),
                "detail_erode": ("INT", {"default": 8, "min": 1, "max": 255, "step": 1}),
                "detail_dilate": ("INT", {"default": 6, "min": 1, "max": 255, "step": 1}),
                "black_point": ("FLOAT", {"default": 0.01, "min": 0.01, "max": 0.98, "step": 0.01, "display": "slider"}),
                "white_point": ("FLOAT", {"default": 0.99, "min": 0.02, "max": 0.99, "step": 0.01, "display": "slider"}),
                "process_detail": ("BOOLEAN", {"default": True}),
                "device": (device_list,),
                "max_megapixels": ("FLOAT", {"default": 2.0, "min": 1, "max": 999, "step": 0.1}),
            }
        }

    RETURN_TYPES = ("IMAGE", "MASK",)
    RETURN_NAMES = ("image", "mask",)
    FUNCTION = "segformer_ultra_v2"
    CATEGORY = 'üò∫dzNodes/LayerMask'

    def segformer_ultra_v2(self, image, segformer_pipeline,
                        detail_method, detail_erode, detail_dilate, black_point, white_point,
                        process_detail, device, max_megapixels,
                        ):
        model = segformer_pipeline.model_name
        labels_to_keep = segformer_pipeline.segment_label
        ret_images = []
        ret_masks = []

        if detail_method == 'VITMatte(local)':
            local_files_only = True
        else:
            local_files_only = False

        for i in image:
            pred_seg, cloth = get_segmentation(i, model_name=model)
            i = torch.unsqueeze(i, 0)
            i = pil2tensor(tensor2pil(i).convert('RGB'))
            orig_image = tensor2pil(i).convert('RGB')

            mask = np.isin(pred_seg, labels_to_keep).astype(np.uint8)

            # ÂàõÂª∫agnostic-maskÂõæÂÉè
            mask_image = Image.fromarray((1 - mask) * 255)
            mask_image = mask_image.convert("L")
            brightness_image = ImageEnhance.Brightness(mask_image)
            mask_image = brightness_image.enhance(factor=1.08)
            _mask = pil2tensor(mask_image)

            detail_range = detail_erode + detail_dilate
            if process_detail:
                if detail_method == 'GuidedFilter':
                    _mask = guided_filter_alpha(i, _mask, detail_range // 6 + 1)
                    _mask = tensor2pil(histogram_remap(_mask, black_point, white_point))
                elif detail_method == 'PyMatting':
                    _mask = tensor2pil(mask_edge_detail(i, _mask, detail_range // 8 + 1, black_point, white_point))
                else:
                    _trimap = generate_VITMatte_trimap(_mask, detail_erode, detail_dilate)
                    _mask = generate_VITMatte(orig_image, _trimap, local_files_only=local_files_only, device=device,
                                              max_megapixels=max_megapixels)
                    _mask = tensor2pil(histogram_remap(pil2tensor(_mask), black_point, white_point))
            else:
                _mask = mask2image(_mask)

            ret_image = RGB2RGBA(orig_image, _mask.convert('L'))
            ret_images.append(pil2tensor(ret_image))
            ret_masks.append(image2mask(_mask))

        log(f"{self.NODE_NAME} Processed {len(ret_images)} image(s).", message_type='finish')
        return (torch.cat(ret_images, dim=0), torch.cat(ret_masks, dim=0),)

NODE_CLASS_MAPPINGS = {
    "LayerMask: SegformerB2ClothesUltra": Segformer_B2_Clothes,
    "LayerMask: SegformerUltraV2": SegformerUltraV2,
    "LayerMask: SegformerClothesPipelineLoader": SegformerClothesPipelineLoader,
    "LayerMask: SegformerFashionPipelineLoader": SegformerFashionPipelineLoader,
}

NODE_DISPLAY_NAME_MAPPINGS = {
    "LayerMask: SegformerB2ClothesUltra": "LayerMask: Segformer B2 Clothes Ultra",
    "LayerMask: SegformerUltraV2": "LayerMask: Segformer Ultra V2",
    "LayerMask: SegformerClothesPipelineLoader": "LayerMask: Segformer Clothes Pipeline",
    "LayerMask: SegformerFashionPipelineLoader": "LayerMask: Segformer Fashion Pipeline"
}

